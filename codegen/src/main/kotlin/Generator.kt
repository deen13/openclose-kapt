import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import de.smartsquare.openclose.annotations.InlinedBall
import de.smartsquare.openclose.annotations.RootBall
import java.io.File
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.Processor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedAnnotationTypes
import javax.annotation.processing.SupportedSourceVersion
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.Name
import javax.lang.model.element.TypeElement

@AutoService(Processor::class)
@SupportedSourceVersion(SourceVersion.RELEASE_11)
@SupportedAnnotationTypes("de.smartsquare.openclose.annotations.InlinedBall")
class Generator : AbstractProcessor() {

    companion object {
        const val KAPT_KOTLIN_GENERATED_OPTION_NAME = "kapt.kotlin.generated"
    }

    private val list = ClassName("kotlin.collections", "List")

    override fun process(annotations: MutableSet<out TypeElement>, roundEnv: RoundEnvironment): Boolean {
        val implementations = roundEnv.getElementsAnnotatedWith(InlinedBall::class.java)

        if (implementations.isNotEmpty()) {
            val root = roundEnv.getElementAnnotatedWith(RootBall::class.java)

            val properties = implementations
                .map { it to it.simpleName.asCamelCaseListName() }
                .map { (element, propName) ->
                    PropertySpec.builder(propName, list.parameterizedBy(element.asType().asTypeName()))
                        .initializer(propName)
                        .build()
                }

            val parameters = implementations.map {
                ParameterSpec
                    .builder(it.simpleName.asCamelCaseListName(), list.parameterizedBy(it.asType().asTypeName()))
                    .build()
            }

            val factoryCode = implementations.joinToString(separator = "\n") {
                "val ${it.simpleName.asCamelCaseListName()} = balls.filterIsInstance<${it.simpleName}>()"
            }

            val returnStatement = implementations.joinToString(
                prefix = "return BallAggregate(",
                separator = ", ",
                postfix = ")",
                transform = { it.simpleName.asCamelCaseListName() }
            )

            val createFunction = FunSpec.builder("create")
                .returns(ClassName("de.smartsquare.openclose", "BallAggregate"))
                .addParameter("balls", list.parameterizedBy(root.asType().asTypeName()))
                .addCode(factoryCode + "\n" + returnStatement)
                .build()

            val factory = TypeSpec.companionObjectBuilder("Factory")
                .addFunction(createFunction)
                .build()

            val aggregate = TypeSpec.classBuilder("BallAggregate")
                .addModifiers(KModifier.DATA)
                .primaryConstructor(FunSpec.constructorBuilder().addParameters(parameters).build())
                .addType(factory)
                .addProperties(properties)
                .addKdoc("This aggregate is generated by :codegen and can be created by using the create function.")
                .build()

            val generatedSourcesRoot = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME].orEmpty()

            FileSpec.builder("de.smartsquare.openclose", "BallAggregate")
                .addType(aggregate)
                .build()
                .writeTo(File(generatedSourcesRoot))

            return true
        }

        return false
    }

    private fun Name.asCamelCaseListName() = "${this.toString().decapitalize()}s"

    private fun RoundEnvironment.getElementAnnotatedWith(annotation: Class<out Annotation>): Element {
        val elements = this.getElementsAnnotatedWith(annotation)

        if (elements.isEmpty()) {
            throw error("Found no element annotated with @${annotation.simpleName}.")
        }

        if (elements.size > 1) {
            throw error("Found multiple types annotated with @${annotation.simpleName} but exaclty one expected.")
        }

        return elements.first()
    }
}
